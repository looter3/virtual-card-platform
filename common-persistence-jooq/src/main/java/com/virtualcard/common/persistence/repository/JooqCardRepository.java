package com.virtualcard.common.persistence.repository;

import static com.jooq.generated.tables.Card.CARD;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.Optional;
import java.util.UUID;

import org.jooq.DSLContext;
import org.springframework.stereotype.Repository;

import com.jooq.generated.enums.CardStatus;
import com.jooq.generated.tables.pojos.CardDTO;
import com.jooq.generated.tables.records.CardRecord;

import lombok.extern.log4j.Log4j2;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

/**
 * @author Lorenzo Leccese
 *
 *         8 giu 2025
 *
 */
@Repository
@Log4j2
public class JooqCardRepository extends AbstractJooqRepository {

	public JooqCardRepository(final DSLContext dsl) {
		super(dsl);
	}

	/**
	 * Inserts a card into the database using the attributes from the provided CardDTO.
	 *
	 * @param dto the CardDTO containing the card details such as id, cardholder name, balance,
	 *                and status to be inserted into the database
	 * @return a Mono signaling when the insertion operation has completed
	 */
	public Mono<Void> insertCardFromDTO(final CardDTO dto) {
		return insertCard(dto.getId(), dto.getCardholdername(), dto.getBalance(), dto.getStatus());
	}

	/**
	 * Inserts a new card with a generated unique UUID as its identifier. The card is initialized with the given
	 * cardholder name, initial balance, and an ACTIVE status, and is then persisted into the database.
	 *
	 * @param cardholderName the name of the cardholder for whom the card is being created
	 * @param initialBalance the initial monetary balance to be associated with the newly created card
	 * @return a {@link Mono} that completes when the card is successfully inserted into the database
	 */
	public Mono<Void> insertCardWithGeneratedUUID(final String cardholderName, final BigDecimal initialBalance) {
		final String id = UUID.randomUUID().toString();
		return insertCard(id, cardholderName, initialBalance, CardStatus.ACTIVE);
	}

	/**
	 * Inserts a card record into the database with the specified ID, cardholder name, and initial balance.
	 * The card is created with an ACTIVE status by default.
	 *
	 * @param id             the unique identifier for the card, which should be pre-generated by the client
	 * @param cardholderName the name of the cardholder to associate with the card
	 * @param initialBalance the initial monetary balance to set on the card
	 * @return a Mono signaling when the operation is completed
	 */
	// TODO Let the client create the UUID maybe using Luhn algorithm
	public Mono<Void> insertCardWithId(final String id, final String cardholderName, final BigDecimal initialBalance) {
		return insertCard(id, cardholderName, initialBalance, CardStatus.ACTIVE);
	}

	/**
	 * Inserts a card record into the database with the specified details.
	 *
	 * @param id             the unique identifier for the card
	 * @param cardholderName the name of the cardholder
	 * @param initialBalance the initial balance to be set for the card
	 * @param status         the status of the card (e.g., ACTIVE or BLOCKED)
	 * @return a Mono signaling when the card has been successfully inserted
	 */
	private Mono<Void> insertCard(final String id, final String cardholderName, final BigDecimal initialBalance, final CardStatus status) {
		return Mono.fromRunnable(() -> dsl.insertInto(CARD)
			.set(CARD.ID, id)
			.set(CARD.CARDHOLDERNAME, cardholderName)
			.set(CARD.BALANCE, initialBalance)
			.set(CARD.CREATEDAT, LocalDateTime.now())
			.set(CARD.STATUS, status)
			.set(CARD.VERSION, 0)
			.execute());
	}

	/**
	 * Fetches a card based on its identifier.
	 *
	 * @param id the unique identifier of the card to retrieve
	 * @return a {@link Mono} emitting the {@link CardDTO} if found, or empty if no card matches the given id
	 */
	public Mono<CardDTO> findCardById(final String id) {
		return Mono.fromCallable(() -> dsl.selectFrom(CARD)
			.where(CARD.ID.eq(id))
			.fetchOneInto(CardDTO.class));
	}

	public Flux<CardDTO> findAllCardsByUserId(final int userId) {
		return Flux.fromIterable(
				dsl.selectFrom(CARD)
					.where(CARD.USERID.eq(userId))
					.fetchInto(CardDTO.class));
	}

	/**
	 * Updates the balance of a card identified by the provided card ID.
	 *
	 * @param id         the unique identifier of the card whose balance should be updated
	 * @param newBalance the new balance value to set for the card
	 * @return a {@code Mono<Void>} signaling completion of the operation
	 */
	public Mono<Void> updateBalanceByCardId(final String id, final BigDecimal newBalance) {
		return Mono.fromRunnable(() -> Optional.ofNullable(dsl.fetchOne(CARD, CARD.ID.eq(id)))
			.map(cardRecord -> cardRecord.setBalance(newBalance))
			.ifPresent(CardRecord::store));
	}

}
